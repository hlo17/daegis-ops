# エラーハンドリング判断フレーム（テンプレ）

## 0) 前提（対象タスクの3要素）
- **目的**（何を達成したいか）：
- **中核インバリアント**（壊れると致命的な条件）：
- **観測点**（成功・失敗を判断するログ/ファイル/メトリクス）：

## 1) エラーの種類 × 優先度（即断マトリクス）
| 種類 | 例 | 影響 | 取るべき行動 |
|---|---|---:|---|
| **FATAL**（中核破壊） | 主要サービス停止、データ破損、資格情報漏洩 | 甚大 | **即停止**（Stop-the-line）、ロールバック/隔離、原因特定が終わるまで次工程に進まない |
| **BLOCKER**（目的達成不可） | 成果物が出ない、依存API落ち | 大 | **一時停止**、代替経路の検討（≤15分）、ダメならスコープ切替 |
| **DEGRADED**（劣化運転） | 遅延増、サブ機能不全 | 中 | **継続可**（計測しながら）。後でチケット化 |
| **NON-CRITICAL**（周辺） | 表示崩れ、警告 | 小 | **継続**。タスク末尾でまとめて対応 |

## 2) GO / NO-GO ゲート（チェック）
- [ ] コアサービス健全（例 `connected rc=Success`）
- [ ] 観測点で成功が見える（Ledger追記/Slack通知）
- [ ] 副作用が制御下（秘密情報露出なし）
- [ ] ロールバック即可能
- [ ] 切り戻し所要が許容内

## 3) 90秒判断フロー
1) 種類判定（FATAL/BLOCKER/DEGRADED/NON-CRITICAL）
2) FATAL/BLOCKER ⇒ NO-GO（最小再現のみ）  
   それ以外 ⇒ GO（観測点監視）
3) 観測点未達 → スコープ縮小 or 代替経路
4) 振り返り＆Runbook更新

## 4) “走りながら直す”条件
- 観測点は通っている
- 安全側に倒せる代替手段あり
- ロールバック容易
- 影響半径が閉じている（検証環境）

## 5) 作業ログ（貼って使う）
- 実施日時:  
- 目的:  
- 観測点:  
- 実行コマンド:  
- 事象:  
- 種別: [ ] FATAL / [ ] BLOCKER / [ ] DEGRADED / [ ] NON-CRITICAL  
- 判断: [GO/NO-GO] 理由:  
- 対応: 即時 / 暫定 / 恒久  
- 結果: 観測点 達成/未達

---

## 6) ハーネス判定ルール（運用版）
- **GO**: relay検知OK ＆ Ledger反映OK
- **NO-GO**: 下記いずれか
  - relay未達が2回連続
  - Ledger未反映（1回でNO-GO）
- **自動アクション順**:
  1. ハーネスの待ち=3s/窓=10min/リトライ=3回で再検
  2. smokeテスト（mosquitto_sub/ask→answer）
  3. `DEDUPE_OFF=1` で scribe 再起動→再検
  4. 原因確定後、恒久対策と再発防止メモをRunbookに反映

## Changelog
- 2025-09-28: ハーネス待ち/窓/リトライを導入。NO-GO基準を明文化。

---

## 実行粒度（Terminal Hygiene）— ブロック実行 vs 行ごと実行
- **ブロック実行**：ヒアドキュメント、SSH内でさらにシェル、複合パイプ/サブシェル、クォート3段↑、長い置換。
- **行ごと実行**：systemctl/journalctl/grep/tail、export/chmod/bash -n など単発。
- **編集系の固定手順**：生成/置換 → CRLF/BOM/ZWSP掃除 → `bash -n`

### クォート運用（SSH×JSON）
- 原則: 外側 "…"、内側 `"` は `\"`。  
- `'` が要るときは `'...'`"$VAR"`'...'`（閉じ→展開→再開）。
- JSONは `printf '%s\n' "$payload"` パイプ or ヒアドキュメント。

## AI出力の末尾ルール
- ルール追記が要ると判断した回は**回答末尾に追記提案**を添える（対象ファイルも明記）。
